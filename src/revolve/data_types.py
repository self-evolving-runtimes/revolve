from typing_extensions import TypedDict, Literal
from langchain_core.messages import AnyMessage
from datetime import datetime
from typing import Annotated, List, Callable
import operator
from pydantic import BaseModel, Field
import json



class Trace(TypedDict):
    node_name: str
    node_type: str
    node_input:str
    node_output:str
    description: str
    trace_timestamp:datetime


class ForeignKey(TypedDict):
    """ Captures details about a foreign key relation to be used for API generation """
    links_to_table: str
    foreign_column: str
    rel_type:str

class Column(TypedDict):
    """ Captures details about a specific column in a table for which API is being generated """
    column: str
    type: str
    is_primary_key: bool
    foreign_key: ForeignKey
    is_unique: bool
    is_nullable: bool
    is_uid: bool
    enum_values: list[str]


class Table(TypedDict):
    """ Captures details about an individual table for which API is being generated """
    individual_prompt: str
    table_name: str
    columns: list[Column]

class DBSchema(TypedDict):
    """Captures a list of tables for which APIs will get generated"""
    tables: list[Table]

class ClassifyUserRequest(BaseModel):
    """ Classify the user prompt. if user request is a valid task, use "create_crud_task" or "other_tasks". If not use "respond_back" and provide a proper message to the user. """
    classification: Literal["respond_back", "create_crud_task", "other_tasks"]
    message: str


class ApiRoute(TypedDict):
    uri: str
    resource_object: str

class Resource(TypedDict):
    resource_file_name: str
    resource_code:str
    api_route: List[ApiRoute]

class NextNode(BaseModel):
    name:Literal["generate_prompt_for_code_generation", "do_stuff", "do_other_stuff", "__end__"] = Field(
        None, description="The next step in the routing process"
    )

class CodeHistoryMessage(BaseModel):
    new_code:str = Field(
        ...,
        description="The complete code revised by the system. This must include the entire code, not just the part that was changed or fixed."
    )
    what_was_the_problem:str  = Field(
        ...,
        description="The problem that caused the code to be revised",
    )
    what_is_fixed:str = Field(
        ...,
        description="The problem that was fixed by the new code",
    )
    code_type:Literal["resource", "test", "api"] = Field(
        ...,
        description="The type of code that was revised",
    )

class GeneratedCode(BaseModel):
    """ Captures the generated code for a test """
    full_test_code:str = Field(
        ...,
        description="The full test code generated by the system",
    )
class CodeHistory(TypedDict):
    history_type:str # generation, revision
    code:CodeHistoryMessage
    test_report_before_revising: str
    test_report_after_revising:str
    iteration_index:int
    test_revising_input_prompt:List[AnyMessage]

class TestStatus(TypedDict):
    resource_file_name:str
    resource_code:str
    test_generation_input_prompt:List[AnyMessage]
    test_revising_prompt:str
    test_file_name: str
    test_code:str
    status: str # success, failed, fixed, in_progress
    messages: list[AnyMessage]
    code_history:list[CodeHistory]
    iteration_count: int
    table:Table
 
class State(TypedDict):
    messages: Annotated[list[AnyMessage], operator.add]
    trace:Annotated[list, operator.add]
    resources:Annotated[list[Resource], operator.add]
    DBSchema:DBSchema
    next_node:str
    test_status:list[TestStatus]
    send: Callable[[dict], None]
    test_mode:bool
    classification:str

class Readme(TypedDict):
    md_content:str


import json
import typing
from typing import TypedDict, get_type_hints


def is_typed_dict(cls: type) -> bool:
    return isinstance(cls, type) and hasattr(cls, '__annotations__') and hasattr(cls, '__total__')


def typed_dict_to_json_schema(typed_dict_cls: type) -> dict:
    if not is_typed_dict(typed_dict_cls):
        raise TypeError("Expected a TypedDict class")

    annotations = get_type_hints(typed_dict_cls)
    required_keys = getattr(typed_dict_cls, '__required_keys__', set())

    def python_type_to_json_type(tp):
        origin = typing.get_origin(tp)
        args = typing.get_args(tp)

        if origin is list:
            item_type = args[0] if args else typing.Any
            return {
                "type": "array",
                "items": python_type_to_json_type(item_type)
            }

        if origin is dict:
            return {"type": "object"}

        if is_typed_dict(tp):
            return typed_dict_to_json_schema(tp)

        if isinstance(tp, type):
            if issubclass(tp, str):
                return {"type": "string"}
            elif issubclass(tp, int):
                return {"type": "integer"}
            elif issubclass(tp, float):
                return {"type": "number"}
            elif issubclass(tp, bool):
                return {"type": "boolean"}

        return {"type": "string"}

    schema = {
        "type": "object",
        "properties": {},
    }

    required = []
    for key, tp in annotations.items():
        schema["properties"][key] = python_type_to_json_type(tp)
        if key in required_keys:
            required.append(key)

    if required:
        schema["required"] = required

    return schema


def typed_dict_dump_schema_json(typed_dict_cls: type, **json_kwargs) -> str:
    schema = typed_dict_to_json_schema(typed_dict_cls)
    return json.dumps(schema, **json_kwargs)


if __name__ == "__main__":
    print(typed_dict_dump_schema_json(DBSchema, indent=2))


