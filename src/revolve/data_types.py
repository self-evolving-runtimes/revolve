from typing_extensions import TypedDict, Literal
from langchain_core.messages import AnyMessage
from datetime import datetime
from typing import Annotated, List, Callable
import operator
from pydantic import BaseModel, Field
import json



class Trace(TypedDict):
    node_name: str
    node_type: str
    node_input:str
    node_output:str
    description: str
    trace_timestamp:datetime


class ForeignKey(TypedDict):
    """ Captures details about a foreign key relation to be used for API generation """
    links_to_table: str
    foreign_column: str
    rel_type:str

class Column(TypedDict):
    """ Captures details about a specific column in a table for which API is being generated """
    column: str
    type: str
    is_primary_key: bool
    foreign_key: ForeignKey
    is_unique: bool
    is_nullable: bool
    is_uid: bool
    enum_values: list[str]


class Table(TypedDict):
    """ Captures details about an individual table for which API is being generated """
    individual_prompt: str
    table_name: str
    columns: list[Column]

class DBSchema(TypedDict):
    """Captures a list of tables for which APIs will get generated"""
    tables: list[Table]

class ClassifyUserRequest(BaseModel):
    """ Classify the user prompt. if user request is a valid task, use "create_crud_task" or "other_tasks". If not use "respond_back" and provide a proper message to the user. """
    classification: Literal["respond_back", "create_crud_task", "other_tasks"]
    message: str


class ApiRoute(TypedDict):
    uri: str
    resource_object: str

class Resource(TypedDict):
    resource_file_name: str
    resource_code:str
    api_route: List[ApiRoute]

class NextNode(BaseModel):
    name:Literal["generate_prompt_for_code_generation", "do_stuff", "do_other_stuff", "__end__"] = Field(
        None, description="The next step in the routing process"
    )

class CodeHistoryMessage(BaseModel):
    new_code:str = Field(
        ...,
        description="The complete code revised by the system. This must include the entire code, not just the part that was changed or fixed."
    )
    what_was_the_problem:str  = Field(
        ...,
        description="The problem that caused the code to be revised",
    )
    what_is_fixed:str = Field(
        ...,
        description="The problem that was fixed by the new code",
    )
    code_type:Literal["resource", "test", "api"] = Field(
        ...,
        description="The type of code that was revised",
    )

class GeneratedCode(BaseModel):
    """ Captures the generated code for a test """
    full_test_code:str = Field(
        ...,
        description="The full test code generated by the system",
    )
class CodeHistory(TypedDict):
    history_type:str # generation, revision
    code:CodeHistoryMessage
    test_report_before_revising: str
    test_report_after_revising:str
    iteration_index:int
    test_revising_input_prompt:List[AnyMessage]

class TestStatus(TypedDict):
    resource_file_name:str
    resource_code:str
    test_generation_input_prompt:List[AnyMessage]
    test_revising_prompt:str
    test_file_name: str
    test_code:str
    status: str # success, failed, fixed, in_progress
    messages: list[AnyMessage]
    code_history:list[CodeHistory]
    iteration_count: int
    table:Table
 
class State(TypedDict):
    messages: Annotated[list[AnyMessage], operator.add]
    trace:Annotated[list, operator.add]
    resources:Annotated[list[Resource], operator.add]
    DBSchema:DBSchema
    next_node:str
    test_status:list[TestStatus]
    send: Callable[[dict], None]
    test_mode:bool
    classification:str

class Readme(TypedDict):
    md_content:str

if __name__ == "__main__":
    schema = CodeHistoryMessage.model_json_schema()
    print(json.dumps(schema, indent=2))


